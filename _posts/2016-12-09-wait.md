---
layout: post
title:  "Concepts VIII: WAIT element"
date:   2016-12-09 15:49:00 +0000
categories: concepts
---

WAIT element
------------

The posts from this series so far have discussed some standard gates,
such as
[buffers]({{ site.url }}{{ site.baseurl }}/concepts/2015/09/30/buffer.html),
[inverters]({{ site.url }}{{ site.baseurl }}/concepts/2015/10/21/inverter.html)
,
[AND-/OR-gates]({{ site.url }}{{ site.baseurl }}/concepts/2016/08/05/or-causality-1.html)
and
[C-elements]({{ site.url }}{{ site.baseurl }}/concepts/2016/01/13/c-element.html),
as well as discussing the concepts translation tool, and various concepts
required for this.

Now, we can discuss some slightly more complicated devices which can be
specified using concepts. In this post, it will be a *WAIT element*.

Background
----------

Often in asynchronous circuits, it is necessary to split resources between
multiple possible users, in the form of subsystems of a circuit. For example,
if 2 signals, 'a' and 'b' both request access to a device which can only
handle one request at a time. When this happens, an *arbiter* is used, which
helps deal with which request is handled at one time.

A commonly used arbiter is a *mutual exclusion* element, or *mutex*. We have
defined a mutex element to be used with concepts. However, there are some
issues that can occur with a mutex.

For example, if a request, 'a', reaches a mutex, but no request 'b', then 'a'
request will be granted access to the resource. If the 'b' request then comes
while the 'a' request has access, then when it relinquishes that access to the
resource, then 'b' can have access. This would be the same if 'b' arrived
first.

However, what happens if both 'a' and 'b' requests reach the mutex at the
exact same time. In this case, there is no order based decision for which
request is granted access first, and in fact, due to the implementation of a
mutex element, it would mean that due to the fact that a decision is not made,
the mutex reaches a *metastable state*.

This means that neither grants are given, these grant signals are not *high*,
meaning that neither request has access to the resource. However, neither
grant is *low* either. These both exist in a state which is somewhere in the
middle. Due to this, it means that the mutex element is effectively stuck.

Metastability in a mutex is resolved simply by waiting. Eventually, one of the
signals will trend towards being high, and the other will therefore become
low. This process is usually quite quick, however, it is not as
instantaenous as if the requesrs arrived one after the other, and these delays
can cause problems in an asynchronous circuit. Furthermore, there is no
maximum time that the metastability resolution takes, and as such, the length
of time it takes could be increcibly long.

While metastability is being resolved, the signal that is trending towards
high will gradually reach it, but the resource it is aiming to access will
have a threshold voltage, over which a signal is registered as high, and below
which, is either 0, or registered as metastable.

The WAIT element was designed in order to detect a trending-towards-high
signal earlier, and quickly pass this onto a resource as an actually high
signal, but how does this work?

WAIT specification
------------------

![WAIT element schematic]({{ site.url }}{{ site.baseurl }}/images/circuit-WAIT-box.svg)

This is the symbol for a WAIT element. There are three sigals involved:

`sig` - This is the input signal, the signal which from the above example,
will be the grant signal for access to the resource, which could be metastable.

`san` - The output signal, which will be used to access the resource. As soon
as it is detected that `sig` is high, `san` will be set high, providing the
element is in the correct mode.

`ctrl` - Is another input which determines what mode the element is in. *High*
will mean that it is in *WAIT mode*, awaiting `sig` going high, to immediatley
setting `san` high in this mode. *Low* means that it is in dormant mode. It
enters this state after `san` goes high.

Immediatley from this information, we can define the interface:

{% highlight haskell %}
interface = inputs [sig, ctrl] <> outputs [san]
{% endhighlight %}

Next, let's discuss their interactions. As said in the signal descriptions, as
soon as `sig` is determined to be high, `san` is set high. We can describe
this in concepts as:

{% highlight haskell %}
outputHigh = sig+ ~> san+
{% endhighlight %}

What about the mode? Well, as stated, for `san` to go high, `sig` must be
high, and the element must be in WAIT mode, or when `ctrl` is high. Once `san`
does go high, the element enters dormant mode, so `ctrl` becomes low.
Following the access to the resource being used, `san` will go low once again,
allowing the element to enter WAIT mode once again. In concepts, this can be:

{% highlight haskell %}
modeSelect = ctrl+ ~> san+ <> san+ ~> ctrl- <> ctrl- ~> san- <> san- ~>ctrl+
{% endhighlight %}

You may recognise the patter of this concepts, it is infact a Handshake. Thus
we can reuse the pre-defined Handshake concept instead of this:

{% highlight haskell %}
modeSelect = handshake ctrl san
{% endhighlight %}

Finally, we need to thin of initial states. Since we are awaiting `sig` to go
high, we can safely state that this will initially be low. Since `san` follows
`sig` as soon as it is detected to be high, we can also assume `san` is
initially low. The WAIT element itself should start in the dormant mode, until
resources start getting access requests so we can also state that `ctrl` is
initially low:

{% highlight haskell %}
initial = initialise0 [sig, san, ctrl]
{% endhighlight %}

So let's compile these concepts for a single specification, to be translated
by the [tool](https://github.com/tuura/concepts):

{% highlight haskell %}
waitElement sig san ctrl = outputHigh <> modeSelect <> interface <> initial
	where
		outputHigh = sig+ ~> san+
		modeSelect = handshake ctrl san
		interface = inputs [sig, ctrl] <> outputs [san]
		initial = initialise0 [sig, san, ctrl]
{% endhighlight %}

Translated, we find the following STG:

![translated WAIT element STG]({{ site.url }}{{ site.baseurl }}/images/WAIT-stg.svg)

This isn't too revealing, but simulations prove that it works as expected.
Let's resynthesize it and find a nicer layout.

![resynthesized translated WAIT element STG]({{ site.url }}{{ site.baseurl }}/images/WAIT-stg-resynth.svg)

This reveals exactly how we discussed the design, with the handshake and the
`sig` and `san` interaction.

A note
------

The `ctrl` signal used in conjunction with this itself features some complex
logic. Whether this can be designed with concepts is currently under review,
but it it's necessary to make it known that this WAIT element will not work
well without the sophisticated `ctrl` signal.

Due to the design process of concepts, it is possible to specify the circuit
which produces `ctrl` as another scenario, to then include with this scenario
concept, and produce a couple of STGs, or one which encompasses both
scenarios.

Finally
-------

This post has featured an entirely different gate to those we have used before,
but using the same concepts we have been using all along. What's more is this
can be included in the tool as a standard, and it's been designed quite
easily. Obviously it will need the `ctrl` signal logic to also be specified
correctly, but in due course this may work as well!

Concepts are proving to make specifying many different gates and scenarios
with differing uses simple, when broken down into a set of simple to
understand concepts based on signal-, protocol- or gate-level concepts,
allowing users to choose how they like to think of the designs, and work in
this way.

Next up, a related gate, the WAITX element. This takes the WAIT element and
provides some greater functions, for the same reasons, and leaves us with a
much more powerful overall design for the metastability case.
